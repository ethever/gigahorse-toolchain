#pragma once

//// ** Recognize structured loops and related stuff **

.decl StructuredLoopBackEdge(from: Block, to: Block)
.decl StructuredLoopHead(s: Block)

StructuredLoopBackEdge(from, to),
StructuredLoopHead(to) :-
  LocalBlockEdge(from, to),
  Dominates(to, from).

// Detect a loop body *without* also capturing surrounding loops (i.e., not just SCC)
.decl BlockInStructuredLoop(s: Block, loophead: Block)
/**
  Base of above relation, excluding terminating statements inside the loop
*/
.decl BlockInStructuredLoopBase(s: Block, loophead: Block)

BlockInStructuredLoopBase(backEdgeNode, loophead) :- StructuredLoopBackEdge(backEdgeNode, loophead).
BlockInStructuredLoopBase(loophead, loophead) :- StructuredLoopHead(loophead).

// Can reach back edge node without going through loop head!
BlockInStructuredLoopBase(s, loophead) :-
  BlockInStructuredLoopBase(other, loophead),
  LocalBlockEdge(s, other),
  other != loophead.

BlockInStructuredLoop(block, loop):-
  BlockInStructuredLoopBase(block, loop).

// If non terminating loop exit exists, consider terminating ones part of the loop
BlockInStructuredLoop(termBlock, loop):-
  LoopNextBase(loop, _),
  LoopToTerminatingBlock(loop, termBlock).

BlockInStructuredLoop(termBlock, loop):-
  LoopNextBase(loop, _),
  LoopToTerminatingBlock(loop, termOne),
  // reverts can span across multiple blocks (connected via direct jumps)
  LocalBlockPath(termOne, termBlock).

.decl StatementInStructuredLoop(s: Statement, loop: Block)
StatementInStructuredLoop(s, loop) :-
   BlockInStructuredLoop(b, loop),
   Statement_Block(s, b).


/**
  Block that will be executed after the loop completes.
  We first define `LoopNextBase` as an exit to a non-terminating block.  
  If such a fact exists, we consider it `LoopNext` and "exits" to terminating blocks as part of the loop.  
  If no such fact is produced we consider exits to terminating blocks as `LoopNext` facts.
  (This mostly covers cases where a revert message is copied using a loop, followed by a `REVERT`).
*/
.decl LoopNext(loop: Block, next: Block)
DEBUG_OUTPUT(LoopNext)
// Internal relation: Loop exits to a non-terminating block
.decl LoopNextBase(loop: Block, next: Block)
// Internal relation: Loop exits to a terminating (with regards to the current function) block 
// (revert, exit, returnprivate, return)
.decl LoopToTerminatingBlock(loop: Block, termBlock: Block)

LoopNext(loop, next):-
  LoopNextBase(loop, next).

LoopNext(loop, termBlock):-
  LoopToTerminatingBlock(loop, termBlock),
  !LoopNextBase(loop, _).

LoopNextBase(loop, out):-
  BlockInStructuredLoopBase(jmpiBlock, loop),
  Block_Tail(jmpiBlock, jmpi),
  JUMPI(jmpi, _, _),
  LocalBlockEdge(jmpiBlock, out),
  !BlockInStructuredLoopBase(out, loop),
  !ThrowBlock(out),
  !FunctionExit(out).

LoopToTerminatingBlock(loop, termBlock):-
  BlockInStructuredLoopBase(jmpiBlock, loop),
  Block_Tail(jmpiBlock, jmpi),
  JUMPI(jmpi, _, _),
  LocalBlockEdge(jmpiBlock, termBlock),
  (ThrowBlock(termBlock); FunctionExit(termBlock)).

/**
  Loops that can be expressed using high-level control-flow
*/
.decl HighLevelLoop(loop: Block)
HighLevelLoop(loop):-
  BlockInStructuredLoop(_, loop),
  1 = count : LoopNext(loop, _).

/**
  We consider it a high-level loop if it has more than one next blocks
  but all are terminating ones.
*/
HighLevelLoop(loop):-
  BlockInStructuredLoop(_, loop),
  n_next = count : LoopNext(loop, _),
  n_next > 1,
  n_next_term = count : LoopToTerminatingBlock(loop, _),
  n_next_term = n_next.

// condVar determines whether a loop is exited
.decl LoopExitCond(condVar: Variable, loop: Block)
.decl LoopExitCondPredicateTrue(condVar: Variable, loop: Block, if_head: Block)
.decl LoopExitCondPredicateFalse(condVar: Variable, loop: Block, if_head: Block)

LoopExitCond(condVar, loop) :-
   BlockInStructuredLoopBase(jmpiBlock, loop),
   Block_Tail(jmpiBlock, jmpi),
   JUMPI(jmpi, _, condVar),
   LocalBlockEdge(jmpiBlock, out),
   LoopNext(loop, out),
   LocalBlockEdge(jmpiBlock, in),
   BlockInStructuredLoopBase(in, loop).


LoopExitCondPredicateTrue(condVar, loop, jmpiBlock) :-
   BlockInStructuredLoopBase(jmpiBlock, loop),
   Block_Tail(jmpiBlock, jmpi),
   JUMPI(jmpi, _, condVar),
   LocalBlockEdge(jmpiBlock, out),
   LoopNext(loop, out),
   FallthroughEdge(jmpiBlock, in),
   BlockInStructuredLoopBase(in, loop).

DEBUG_OUTPUT(LoopExitCond)
DEBUG_OUTPUT(LoopExitCondPredicateTrue)
DEBUG_OUTPUT(LoopExitCondPredicateFalse)
LoopExitCondPredicateFalse(condVar, loop, jmpiBlock) :-
   BlockInStructuredLoopBase(jmpiBlock, loop),
   Block_Tail(jmpiBlock, jmpi),
   JUMPI(jmpi, _, condVar),
   FallthroughEdge(jmpiBlock, out),
   LoopNext(loop, out),
   LocalBlockEdge(jmpiBlock, in),
   BlockInStructuredLoopBase(in, loop).


.decl CanReachBlock(s:Block, t:Block)

CanReachBlock(x, y), CanReachBlock(y, y), CanReachBlock(x, x) :- LocalBlockEdge(x, y).
CanReachBlock(x, z) :- CanReachBlock(x, y), LocalBlockEdge(y, z).

.decl InSameSCC(x:Block, y:Block)
InSameSCC(y, y), InSameSCC(x, x) :- LocalBlockEdge(x, y).
InSameSCC(x, y) :- CanReachBlock(x,y), CanReachBlock(y,x).

.decl InSameSCCLoop(x:Block, y:Block)
InSameSCCLoop(x, y) :- InSameSCC(x, y), (x != y ; LocalBlockEdge(x, y)).

.decl BlockInSCCLoop(x:Block, scc: number)

BlockInSCCLoop(x, scc) :-
   IsBlock(x),
   scc = min ord(y) : InSameSCCLoop(x, y).



