#pragma once

//// ** Recognize structured loops and related stuff **

.decl StructuredLoopBackEdge(from: Block, to: Block)
.decl StructuredLoopHead(s: Block)

StructuredLoopBackEdge(from, to),
StructuredLoopHead(to) :-
  LocalBlockEdge(from, to),
  Dominates(to, from).

// Detect a loop body *without* also capturing surrounding loops (i.e., not just SCC)
.decl BlockInStructuredLoop(s: Block, loophead: Block)
/**
  Base of above relation, excluding reverting statements inside the loop
*/
.decl BlockInStructuredLoopBase(s: Block, loophead: Block)

BlockInStructuredLoopBase(backEdgeNode, loophead) :- StructuredLoopBackEdge(backEdgeNode, loophead).
BlockInStructuredLoopBase(loophead, loophead) :- StructuredLoopHead(loophead).

// Can reach back edge node without going through loop head!
BlockInStructuredLoopBase(s, loophead) :-
  BlockInStructuredLoopBase(other, loophead),
  LocalBlockEdge(s, other),
  other != loophead.

BlockInStructuredLoop(block, loop):-
  BlockInStructuredLoopBase(block, loop).

// If non reverting loop exit exists, consider reverting ones part of the loop
BlockInStructuredLoop(revertBlock, loop):-
  LoopNextBase(loop, _),
  LoopToRevert(loop, revertBlock).

BlockInStructuredLoop(revertBlock, loop):-
  LoopNextBase(loop, _),
  LoopToRevert(loop, revertOne),
  // reverts can span across multiple blocks (connected via direct jumps)
  LocalBlockPath(revertOne, revertBlock).

.decl StatementInStructuredLoop(s: Statement, loop: Block)
StatementInStructuredLoop(s, loop) :-
   BlockInStructuredLoop(b, loop),
   Statement_Block(s, b).


/**
  Block that will be executed after the loop completes.
  We first define `LoopNextBase` as an exit to a non-terminating block.  
  If such a fact exists, we consider it `LoopNext` and "exits" to reverting blocks as part of the loop.  
  If no such fact is produced we consider exits to reverting blocks as `LoopNext` facts.
  (This mostly covers cases where a revert message is copied using a loop, followed by a `REVERT`).
*/
.decl LoopNext(loop: Block, next: Block)
DEBUG_OUTPUT(LoopNext)
// Internal relation: Loop exits to a non-terminating block
.decl LoopNextBase(loop: Block, next: Block)
// Internal relation: Loop exits to a reverting block
.decl LoopToRevert(loop: Block, revertBlock: Block)

LoopNext(loop, next):-
  LoopNextBase(loop, next).

LoopNext(loop, revertBlock):-
  LoopToRevert(loop, revertBlock),
  !LoopNextBase(loop, _).

LoopNextBase(loop, out):-
  BlockInStructuredLoopBase(jmpiBlock, loop),
  Block_Tail(jmpiBlock, jmpi),
  JUMPI(jmpi, _, _),
  LocalBlockEdge(jmpiBlock, out),
  !BlockInStructuredLoopBase(out, loop),
  !ThrowBlock(out).

LoopToRevert(loop, revertBlock):-
  BlockInStructuredLoopBase(jmpiBlock, loop),
  Block_Tail(jmpiBlock, jmpi),
  JUMPI(jmpi, _, _),
  LocalBlockEdge(jmpiBlock, revertBlock),
  ThrowBlock(revertBlock).

// condVar determines whether a loop is exited
.decl LoopExitCond(condVar: Variable, loop: Block)
.decl LoopExitCondPredicateTrue(condVar: Variable, loop: Block, if_head: Block)
.decl LoopExitCondPredicateFalse(condVar: Variable, loop: Block, if_head: Block)

LoopExitCond(condVar, loop) :-
   BlockInStructuredLoopBase(jmpiBlock, loop),
   Block_Tail(jmpiBlock, jmpi),
   JUMPI(jmpi, _, condVar),
   LocalBlockEdge(jmpiBlock, out),
   LoopNext(loop, out),
   LocalBlockEdge(jmpiBlock, in),
   BlockInStructuredLoopBase(in, loop).


LoopExitCondPredicateTrue(condVar, loop, jmpiBlock) :-
   BlockInStructuredLoopBase(jmpiBlock, loop),
   Block_Tail(jmpiBlock, jmpi),
   JUMPI(jmpi, _, condVar),
   LocalBlockEdge(jmpiBlock, out),
   LoopNext(loop, out),
   FallthroughEdge(jmpiBlock, in),
   BlockInStructuredLoopBase(in, loop).

LoopExitCondPredicateFalse(condVar, loop, jmpiBlock) :-
   BlockInStructuredLoopBase(jmpiBlock, loop),
   Block_Tail(jmpiBlock, jmpi),
   JUMPI(jmpi, _, condVar),
   FallthroughEdge(jmpiBlock, out),
   LoopNext(loop, out),
   LocalBlockEdge(jmpiBlock, in),
   BlockInStructuredLoopBase(in, loop).


.decl CanReachBlock(s:Block, t:Block)

CanReachBlock(x, y), CanReachBlock(y, y), CanReachBlock(x, x) :- LocalBlockEdge(x, y).
CanReachBlock(x, z) :- CanReachBlock(x, y), LocalBlockEdge(y, z).

.decl InSameSCC(x:Block, y:Block)
InSameSCC(y, y), InSameSCC(x, x) :- LocalBlockEdge(x, y).
InSameSCC(x, y) :- CanReachBlock(x,y), CanReachBlock(y,x).

.decl InSameSCCLoop(x:Block, y:Block)
InSameSCCLoop(x, y) :- InSameSCC(x, y), (x != y ; LocalBlockEdge(x, y)).

.decl BlockInSCCLoop(x:Block, scc: number)

BlockInSCCLoop(x, scc) :-
   IsBlock(x),
   scc = min ord(y) : InSameSCCLoop(x, y).



